## Algorithm TIL

◾ 230720 목

### 배열 (Array)

- 가장 기본적인 자료구조.
- 여러개의 변수를 담는 공간
- 배열은 index가 존재함
- 특정한 인덱스테 직접적 접근가능 -> 수행기간 : O(1)

### 배열의 특징

- 컴퓨터의 메인 메모리에서 배열의 공간은 연속적으로 할당됨.
- 장점 : 케시 히트 가능성이 높으며, 조회가 빠름
- 단점 : 배열의 크기를 미리 지정해야하는 것이 일반적이므로,
  데이터의 추가 및 삭제에 한계가 있음.
  (자바스크립트는 동적배열의 기능을 가지고 있어서 배열 원소 추가 가능)

### 연결 리스트 (Linked List)

- 연결 리스트는 컴퓨터의 메인 메모리상에서 주소가 연속적이지 않음.
- 배열과 다르게 크기가 정해져 있지 않고, 리스트의 크기는 동적으로 변경 가능함.
- 장점 : 포인터를 통해 다음 데이터의 위치를 가리킨다는 점에서 삽입과 삭제가 가능함.
- 단점 : 특정 번째의 원소를 검색할 때는 앞에서부터 원소를 찾아야 하므로, 데이터의 검색 속도가 느림.
- 각 노드가 한 줄로 연결되어있는 자료구조로 각 노드는 (데이터,포인터) 형태를 가진다.
  - 포인터 : 다음 노드의 메모리 주소를 가리키는 목적으로 사용
  - 연결성 : 각 노드의 포인터는 다음 혹은 이전 노드를 가리킴
- 연결 리스트는 다양한 자료구조를 구현할 수 있음
  - 예시 : 스택, 큐등
- 자바스크립트는 연결 리스트를 활용하는 자료구조를 제공
  ![linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20220712172013/Singlelinkedlist.png)

### 자바스크립트의 배열

- 자바스크립트의 배열 자료형은 동적 배열
- 배열의 용량이 가득차면, 자동으로 크기를 증가시킴
- 내부적으로 포인터를 사용하여 연결 리스트의 장점도 가지고 있음
- 배열 혹은 스택의 기능이 필요할 때 사용 가능.
  (큐 기능은 제공 X -> 비효율적)

```js
// 배열 생성
const arr = [];
const arr2 = new Array();

// 임의의 크기를 가지는 배열 생성
const arr3 = [1, 2, 3];
const arr4 = Array.from({ length: 5 }, () => 7);

// 2차원 배열
const arr5 = [
	[0, 1, 2],
	[3, 4, 5],
	[6, 7, 8],
];

const arr6 = Array.from(Array(4), () => new Array(5));

// concat() O(N)
const arr1 = [1, 2];
const arr2 = [3, 4];
const merged = arr1.concat(arr2, [5, 6], [7]);

// slice() O(N)
const arr = [0, 1, 2, 3];
const sliced = arr.slice(2, 3);

// indexOf O(N)
// - 특정 값을 가지는 원소의 첫번째 인덱스 반환
// - 없는 경우 -1 리턴
const arr = [1, 2, 3, 4, 5];
console.log(arr.indexOf(1)); // 0
console.log(arr.indexOf(6)); // -1
```

### 연결리스트 vs 배열

- 특정 위치의 데이터 삭제 시
  - 일반 배열에는 O(N)만큼의 시간이 소요됨.
  - 연결리스트는 삭제 위치를 정확히 아는 경우 O(1)의 시간 소요
    - 단순히 연결만 끊으면 됨.
- 연결리스트의 경우 삽입할 위치를 알면 위치를 옮기지 않고 포인터를 변경한다.
